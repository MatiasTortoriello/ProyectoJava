program{
    lista:= [1,3,4]
    otraLista:= [13,21,3,9,45,17,8,3,7]
    return ( sinMaximoElemento_(otraLista))
}
//////////////////////////////////////////////////

function contiene_A_(unaLista,unElemento){
    restoDeLista:= unaLista
    while(not esVacía(restoDeLista) && unElemento/= primero(restoDeLista)){
        restoDeLista:= resto(restoDeLista)
    }
    return(not esVacía(restoDeLista) && unElemento == primero(restoDeLista))
}
//////////////////////////////////////////////////
 
function  productoriaDe_(lista){
    total:= primero(lista)
    unaLista:= resto(lista)
    while(not esVacía(unaLista)){
        total:= total * primero(unaLista)
        unaLista:= resto(unaLista)
    }
    return(total)
    
}
//////////////////////////////////////////////////

function direccionesOpuestasDe_(lista){
    nuevaLista:= []
    unaLista:= lista
    while(not esVacía(unaLista)){
        direccionDada:= opuestoDe_(primero(unaLista))
        nuevaLista:= nuevaLista ++ [direccionDada] 
        unaLista:= resto(unaLista)
    }
    return(nuevaLista)
}
//////////////////////////////////////////////////

function opuestoDe_(direccion){
    return(
            choose
                Sur when (direccion == Norte)
                Oeste when (direccion == Este)
                Norte when ( direccion == Sur)
                Este otherwise
        )
}
//////////////////////////////////////////////////

function siguientesDe_(lista){
    listaSiguiente:= []
    unaLista:= lista
    while(not esVacía(unaLista)){
        siguienteDe:= siguiente(primero(unaLista))
        listaSiguiente:= listaSiguiente ++ [siguienteDe]
        unaLista:= resto(unaLista)
    }
    return(listaSiguiente)
}
//////////////////////////////////////////////////

function elementosDe_multiplicadosPor_(lista,numero){
    restoDeLista:= lista
    listaTotal:= []
    multiplicador:= numero
    while(not esVacía(restoDeLista)){
        resultado:= multiplicador * primero(restoDeLista)
        listaTotal:= listaTotal ++ [resultado]
        restoDeLista:= resto(restoDeLista)
    }
    return(listaTotal)

}
//////////////////////////////////////////////////

function numeroParesDe_(unaLista){
    restoDeLista:= unaLista
    listaDePares:= []
    while(not esVacía(restoDeLista)){
        numeroPar:= esPar_(primero(restoDeLista))
        
        listaDePares:= listaDePares ++ numeroPar
        
        restoDeLista:= resto(restoDeLista)
    }
    return(listaDePares)
    
}

function esPar_(unNumero){
  return(
        choose
            [unNumero] when (unNumero mod 2 == 0)
            [] otherwise
      )
}
//////////////////////////////////////////////////

function laLista_SinElElemento_(unaLista,unElemento){
    listaNueva:= []
    restoDeLista:= unaLista
    while(not esVacía(restoDeLista)){
        elementoDeLista:= filtrar_Por_(primero(restoDeLista),unElemento)
        listaNueva:= listaNueva ++ elementoDeLista
        restoDeLista:= resto(restoDeLista)
    }
    return(listaNueva)
} 

function filtrar_Por_(unElemento,filtro){
    return(
            choose
                [] when (unElemento == filtro)
                [unElemento] otherwise
        )
}
//////////////////////////////////////////////////

function losMayoresA_De_(umbral,unaLista){
    /*Proposito: Describe los elementos mayores a "umbral" de la lista "unaLista"*/
    restoDeLista:= unaLista
    listaDeMayores:= []
    while(not esVacía(restoDeLista)){
        elementoMayor:= esMayor_Que_(umbral,primero(restoDeLista))
        listaDeMayores:= listaDeMayores ++ elementoMayor
        restoDeLista:= resto(restoDeLista)
    }
    return(listaDeMayores)
}
function esMayor_Que_(umbral,unNumero){
    return(
            choose
                [unNumero] when (unNumero > umbral)
                [] otherwise
       )
} 
//////////////////////////////////////////////////

function hayAlgunoDe_Entre_Y_(unaLista,numero1,numero2){
        /* Proposito: Indica  en una lista de "unaLista"  si hay almenos un numero que este entre "numero1" y "numero2"*/
        restoDeLista:= unaLista
        while(not es_UnNumeroEntre_Y_(unNumero,numero1,numero2) && not esVacía(restoDeLista) ){
            unNumero:= primero(restoDeLista)
            restoDeLista:= resto(restoDeLista)
        }
        return(es_UnNumeroEntre_Y_(unNumero,numero1,numero2))
}
function es_UnNumeroEntre_Y_(numeroDeComparacion,numero1,numero2){
    return((numeroDeComparacion < numero2 ) && (numeroDeComparacion > numero1))
}
//////////////////////////////////////////////////

function hayAlgúnElementoImparDe_(unaLista){
    /*Proposito: Indica si hay algun elemento de la lista "unaLista" que sea impar*/
    restoDeLista:= unaLista
    numeroDeComparacion:= primero(restoDeLista)
    while(not (esImpar_(numeroDeComparacion)) && not esVacía(restoDeLista)){
        numeroDeComparacion:= primero(restoDeLista)
        restoDeLista:= resto(restoDeLista)
    }
    return( esImpar_(numeroDeComparacion))
}
function esImpar_(unNumero){
    return(
            unNumero mod 2 /= 0
        )
}
//////////////////////////////////////////////////
function sinDuplicados_(unaLista){
    /*Proposito: describe la lista "unaLista" sin los elemento duplicados si tiene*/
    listaVieja:= unaLista
    listaSinDuplicados:= []
    while(not esVacía(listaVieja)){
        listaSinDuplicados:= listaSinDuplicados ++ [primero(listaVieja)]
        listaVieja:= laLista_SinElElemento_(listaVieja,primero(listaVieja))
    }
    return(listaSinDuplicados)
}
//////////////////////////////////////////////////

function esta_IncluidaEn_(lista,otraLista){
    restoDeLista:= lista
    while(not esVacía(restoDeLista) && contiene_A_(otraLista,primero(restoDeLista))){
     restoDeLista:= resto(restoDeLista)   
    }
    return(esVacía(restoDeLista))
}
//////////////////////////////////////////////////
function intersecciónDe_Con_(unaLista,otraLista){
   
    listaAComparar:= unaLista
     interseccion:= []
    while(not esVacía(listaAComparar)){
        numeroEnInterseccion:= esInterseccion_Con_(otraLista,primero(listaAComparar))
        interseccion:= interseccion ++ [numeroEnInterseccion]
        listaAComparar:= resto(listaAComparar)
    }   
    return(interseccion)
}

function esInterseccion_Con_(unaLista,unElemento){
    restoDeLista:=unaLista
    while(not esVacía(restoDeLista) && not(contiene_A_(restoDeLista,unElemento))){
        restoDeLista:=resto(restoDeLista)
    }
    return(
            choose
                unElemento when (contiene_A_(restoDeLista, unElemento))
                [] otherwise
        )
    
}
//////////////////////////////////////////////////

function uniónDe_Con_(unaLista,listaDeUnion){
    unionDeLista:= unaLista ++ listaDeUnion
    return(sinDuplicados_(unionDeLista))
}
//////////////////////////////////////////////////

function minimoElementoDe_(unaLista){
    restoDeLista:= unaLista
    minimoElemento:= primero(restoDeLista)
    while(not esVacía(restoDeLista)){
        minimoElemento:= minimoentre_Y_(minimoElemento,primero(restoDeLista))
        restoDeLista:= resto(restoDeLista)
    }
    return(minimoElemento)
}

function minimoentre_Y_(unNumero,otroNumero){
    return(
            choose
                unNumero when (unNumero <= otroNumero)
                otroNumero otherwise
        )
    
}
//////////////////////////////////////////////////

function sinElMínimoElemento_(unaLista){
        /*Proposito: que dada una lista "unaLista" elimine el elemento minimo
            una sola vez*/
        aunQueda:= unaLista
        nuevaLista:= []
        elementoAEliminar:= minimoElementoDe_(aunQueda)
        while(not esVacía(aunQueda) && primero(aunQueda) /= elementoAEliminar ){
            nuevaLista:= nuevaLista ++ [primero(aunQueda)]
            aunQueda:= resto(aunQueda)
        }
        
        return(nuevaLista ++ resto(aunQueda))
}
//////////////////////////////////////////////////

function lista_ordenada(unaLista){
    /*Proposito: devuelve la lista "unaLista" ordenada de menor a mayor*/
  listaVieja:= unaLista
  listaOrdenada:= []
 
  while(not esVacía(listaVieja)){
    numero:= maximoEntre_Y_(minimoElementoDe_(listaVieja),minimoElementoDe_(listaVieja))
    listaOrdenada:= listaOrdenada ++ [numero]
    listaVieja:= sinElMínimoElemento_(listaVieja)
  }
  return(listaOrdenada)
}

function maximoElementoDe_(unaLista){
    restoDeLista:= unaLista
    mayorElemento:= primero(restoDeLista)
    while(not esVacía(restoDeLista)){
        mayorElemento:= maximoEntre_Y_(mayorElemento,primero(restoDeLista))
        restoDeLista:= resto(restoDeLista)
    }
    return(mayorElemento)
}
function maximoEntre_Y_(unNumero,otroNumero){
    return(
            choose
                unNumero when (unNumero > otroNumero)
                otroNumero otherwise
        )
    
}
function sinMaximoElemento_(unaLista){
        restoDeLista:= unaLista
        listaSinMaximo:= []
        maximo:= maximoElementoDe_(restoDeLista)
        while(not esVacía(restoDeLista) && primero(restoDeLista) /= maximo){
            listaSinMaximo:= listaSinMaximo ++ [primero(restoDeLista)]
            restoDeLista:= resto(restoDeLista)
        }
        return(listaSinMaximo ++ resto(restoDeLista))
}
function reversoDe_(unaLista) {
    listaReversa := []
    listaOriginal := unaLista
    while (not esVacía(listaOriginal)) {
        listaReversa := [primero(listaOriginal)] ++ listaReversa
        listaOriginal := resto(listaOriginal)
    }
    return (listaReversa)
}
